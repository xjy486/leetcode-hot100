class Solution {
    public int firstMissingPositive(int[] nums) {
        // 获取数组的长度，n也代表了我们关心的正数的最大范围 [1, n]
        int n = nums.length;

        // =========================================================
        // 阶段一：将每个数字“送回家”（原地哈希/循环排序）
        // =========================================================
        for (int i = 0; i < n; i++) {
            // 当 nums[i] 在 [1, n] 范围内，并且它还没有在正确的位置上时，就不断交换
            // 正确的位置是：数字 k 应该在索引 k-1 的位置
            // nums[nums[i] - 1] != nums[i] 是为了防止出现重复数字时，陷入无限循环
            while (nums[i] >= 1 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                // 执行交换操作
                // 经典的 temp 交换法
                int temp = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i] = temp;
            }
        }

        // =========================================================
        // 阶段二：查找第一个没有待在自己家的数字
        // =========================================================
        for (int i = 0; i < n; i++) {
            // 如果在索引 i 的位置上，数字不是 i+1，
            // 那么 i+1 就是我们找到的第一个缺失的正数
            if (nums[i] != i + 1) {
                return i + 1;
            }
        }

        // 如果上面的循环跑完了都没有返回，说明数组是 [1, 2, 3, ..., n]
        // 这种情况下，第一个缺失的正数就是 n+1
        return n + 1;
    }
}