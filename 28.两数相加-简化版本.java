/**
 * 解决方案类 - 两数相加（简化版本）
 * 
 * 算法特点：
 * 1. 一次遍历完成计算，无需额外数据结构
 * 2. 使用虚拟头节点简化链表构建
 * 3. 边遍历边处理进位，实时构建结果链表
 * 4. 代码更简洁，空间复杂度更优（O(1)额外空间，只考虑结果链表）
 * 
 * 题目描述：给定两个用链表表示的整数，每个节点包含一个数位，
 * 返回一个新的链表表示它们的和（数字逆序存储）
 * 
 * 示例：输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
 * 输出：7 -> 0 -> 8
 * 解释：342 + 465 = 807
 */
class Solution {
    /**
     * 两数相加主方法（简化实现）
     * 
     * @param l1 第一个链表，表示第一个整数（逆序存储）
     * @param l2 第二个链表，表示第二个整数（逆序存储）
     * @return 返回一个新的链表，表示两个整数之和（逆序存储）
     */
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // 创建指针分别指向两个输入链表的头部，避免直接修改原链表
        ListNode p1 = l1;
        ListNode p2 = l2;

        // 创建虚拟头节点（dummy node），简化边界条件处理
        // 这样就不需要单独处理结果链表的头部插入问题
        ListNode dummy = new ListNode(0); // 虚拟头节点，值无意义
        // tail指针始终指向结果链表的最后一个节点，用于追加新节点
        ListNode tail = dummy;

        // carry表示进位值，初始为0
        // 每次计算时，carry会参与当前位的求和，然后更新为新的进位值
        int carry = 0;

        /**
         * 主循环：同时遍历两个链表
         * 循环条件：任一链表还有节点未处理，或者还有进位需要处理
         * 这个条件确保了即使两个链表长度不同也能正确处理，以及最高位的进位
         */
        while (p1 != null || p2 != null || carry != 0) {
            // 每次循环开始时，sum初始化为进位值
            // 这样可以处理前一位计算产生的进位
            int sum = carry;

            // 处理第一个链表的当前节点
            if (p1 != null) {
                sum += p1.val; // 将当前节点的值加入总和
                p1 = p1.next; // 移动到下一个节点
            }

            // 处理第二个链表的当前节点
            if (p2 != null) {
                sum += p2.val; // 将当前节点的值加入总和
                p2 = p2.next; // 移动到下一个节点
            }

            // 创建新节点存储当前位的计算结果
            // sum % 10得到个位数（考虑进位后的结果）
            tail.next = new ListNode(sum % 10);

            // 移动tail指针到新创建的节点
            tail = tail.next;

            // 计算新的进位值
            // sum / 10得到进位：如果sum>=10则carry=1，否则carry=0
            carry = sum / 10;
        }

        // 返回结果链表（跳过虚拟头节点）
        // dummy.next指向真正的结果链表头部
        return dummy.next;
    }
}

/**
 * 算法复杂度分析：
 * 
 * 时间复杂度：O(max(m, n))，其中m和n分别是两个链表的长度
 * - 需要遍历两个链表的所有节点
 * 
 * 空间复杂度：O(max(m, n))
 * - 主要用于存储结果链表，长度最多为max(m, n) + 1（考虑最高位进位）
 * - 只使用了常数个额外指针变量
 * 
 * 与双端队列版本的对比优势：
 * 1. 无需额外数据结构（双端队列）
 * 2. 内存使用更少，空间局部性更好
 * 3. 代码更简洁，逻辑更清晰
 * 4. 一次遍历完成所有计算
 */